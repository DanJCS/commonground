#!/usr/bin/env python3
"""
File: interpreter.py

Summary:
    Interprets a simulation result JSON file (generated by simulation_record.py) and generates scatter plots
    of agent state vectors at specified timesteps.
    
    For each provided timestep:
      - If timestep < avg_window (where avg_window = int(T * 0.04)), it plots the raw state vectors from "records".
      - Otherwise, it plots the moving average state vectors from "final_moving_avg".
    
    The scatter plots are produced in the 2D space (with m fixed to 2) with axes spanning a little beyond [-1,1]
    (or [0,1] for softmax-transformed data if the --softmax argument is provided).
    
Usage:
    python3 interpreter.py --input FILE.json --timesteps 0,1000,2000,3000 [--softmax 1.0] [--output_dir plots]
    
Inputs:
    --input: Path to the simulation result JSON file.
    --timesteps: Comma-separated list of timesteps (e.g., "0,1000,2000,3000").
    --softmax: (Optional) Softmax temperature to generate additional plots of softmax-transformed data.
    --output_dir: (Optional) Directory to save the plots.
    
Outputs:
    For each specified timestep, a scatter plot is saved as a PNG file.
      - If the timestep is less than T*0.04, the plot uses raw state vectors.
      - Otherwise, it uses the moving average state vectors.
    If --softmax is provided, an additional plot is generated for the softmax-converted vectors.
"""

import os
import json
import argparse
import numpy as np
import matplotlib.pyplot as plt

def parse_timesteps(ts_str):
    try:
        return sorted([int(ts.strip()) for ts in ts_str.split(",")])
    except Exception as e:
        raise argparse.ArgumentTypeError(f"Invalid timesteps format: {e}")

def plot_scatter(points, title, xlim, ylim, output_path):
    """
    Generates and saves a scatter plot of 2D points.
    """
    plt.figure(figsize=(6,6))
    if points:
        xs, ys = zip(*points)
    else:
        xs, ys = [], []
    plt.scatter(xs, ys, color="grey")
    plt.title(title)
    plt.xlabel("Dimension 1")
    plt.ylabel("Dimension 2")
    plt.xlim(xlim)
    plt.ylim(ylim)
    # Draw dotted boundary around the domain
    plt.plot([xlim[0], xlim[1], xlim[1], xlim[0], xlim[0]],
             [ylim[0], ylim[0], ylim[1], ylim[1], ylim[0]],
             linestyle=":", color="red")
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"Saved plot: {output_path}")

def main():
    parser = argparse.ArgumentParser(
        description="Generate scatter plots from a simulation result JSON based on specified timesteps."
    )
    parser.add_argument("--input", type=str, required=True,
                        help="Path to the simulation result JSON file.")
    parser.add_argument("--timesteps", type=parse_timesteps, required=True,
                        help="Comma-separated list of timesteps to plot (e.g., 0,1000,2000,3000).")
    parser.add_argument("--softmax", type=float, default=None,
                        help="(Optional) Softmax temperature; if provided, also generate softmax-converted plots.")
    parser.add_argument("--output_dir", type=str, default="ts_plots",
                        help="Directory to save the scatter plots (default: ts_plots).")
    args = parser.parse_args()

    os.makedirs(args.output_dir, exist_ok=True)

    # Load simulation result.
    with open(args.input, "r") as f:
        data = json.load(f)

    # Assume the simulation result includes:
    #   - "final_moving_avg": a dict {agent: [state_vector at each timestep]}
    #   - "records": a dict {agent: [raw state_vector at each timestep]}
    #   - "params": which includes "timesteps" (T)
    params = data.get("params", {})
    T = params.get("timesteps", 5000)
    avg_window = int(T * 0.04)  # moving average window as defined in natural_simulation.py

    # Determine which data to use:
    # For timesteps < avg_window, use raw state vectors from "records".
    # Otherwise, use "final_moving_avg".
    if "records" in data:
        raw_data = data["records"]
    else:
        print("Warning: 'records' key not found; falling back to 'final_moving_avg' for all timesteps.")
        raw_data = data.get("final_moving_avg", {})

    moving_data = data.get("final_moving_avg", {})

    # For each timestep specified, generate the scatter plot.
    for ts in args.timesteps:
        if ts < avg_window:
            # Use raw state vectors
            source = raw_data
            domain = (-1.1, 1.1)
            descriptor = "Raw"
        else:
            source = moving_data
            domain = (-1.1, 1.1)
            descriptor = "Moving Average"

        points = []
        for agent, series in source.items():
            if ts < len(series):
                # Each state vector should have length 2
                pt = series[ts]
                pt = tuple(float(x) for x in pt)
                points.append(pt)
        title = f"{descriptor} State Vectors at Timestep {ts}"
        output_path = os.path.join(args.output_dir, f"state_ts{ts}.png")
        plot_scatter(points, title, domain, domain, output_path)

        # Optionally, if softmax conversion is requested.
        if args.softmax is not None:
            soft_points = []
            for agent, series in source.items():
                if ts < len(series):
                    vec = series[ts]
                    # Apply softmax conversion using the provided temperature.
                    # Import softmax from pairwise_similarity.
                    from pairwise_similarity import softmax as ps_softmax
                    soft_vec = ps_softmax(vec, temperature=args.softmax)
                    soft_points.append(tuple(float(x) for x in soft_vec))
            title_soft = f"{descriptor} State Vectors (Softmax T={args.softmax}) at Timestep {ts}"
            # For softmax-converted values, the domain is roughly [0, 1]
            soft_domain = (-0.1, 1.1)
            output_path_soft = os.path.join(args.output_dir, f"state_ts{ts}_softmax.png")
            plot_scatter(soft_points, title_soft, soft_domain, soft_domain, output_path_soft)

if __name__ == "__main__":
    main()
